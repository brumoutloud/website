const Airtable = require('airtable');
const parser = require('lambda-multipart-parser');
const cloudinary = require('cloudinary').v2;
const fetch = require('node-fetch');

const base = new Airtable({ apiKey: process.env.AIRTABLE_PERSONAL_ACCESS_TOKEN }).base(process.env.AIRTABLE_BASE_ID);
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

async function getDatesFromAI(startDate, recurringInfo) {
    if (!GEMINI_API_KEY) return [startDate];
    const prompt = `Based on a start date of ${startDate} and the recurrence rule "${recurringInfo}", provide a comma-separated list of all dates for the next 3 months in format YYYY-MM-DD.`;
    const payload = { contents: [{ parts: [{ text: prompt }] }] };
    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${GEMINI_API_KEY}`;
    try {
        const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        if (!response.ok) return [startDate];
        const result = await response.json();
        const textResponse = result?.candidates?.[0]?.content?.parts?.[0]?.text;
        return textResponse ? textResponse.trim().split(',').map(d => d.trim()) : [startDate];
    } catch (error) {
        console.error("Error calling AI for dates:", error);
        return [startDate];
    }
}

async function uploadImage(file, folder) {
    if (!file) return null;
    try {
        const base64String = file.content.toString('base64');
        const dataUri = `data:${file.contentType};base64,${base64String}`;
        const result = await cloudinary.uploader.upload(dataUri, {
            folder: folder,
            eager: folder === 'brumoutloud_venues' ? [
                { width: 800, height: 600, crop: 'fill', gravity: 'auto', fetch_format: 'auto', quality: 'auto' },
                { width: 400, height: 400, crop: 'fill', gravity: 'auto', fetch_format: 'auto', quality: 'auto' }
            ] : []
        });
        return result;
    } catch (error) {
        console.error("!!! Cloudinary Upload Error:", error);
        throw error;
    }
}

exports.handler = async function (event, context) {
    if (event.httpMethod !== 'POST') {
        return { statusCode: 405, body: JSON.stringify({ message: 'Method Not Allowed' }) };
    }

    try {
        const result = await parser.parse(event);
        const { id, type, 'Recurring Info': recurringInfo } = result;

        if (!id || !type) {
            return { statusCode: 400, body: JSON.stringify({ message: 'Missing required ID or Type.' }) };
        }

        const table = type === 'Event' ? base('Events') : base('Venues');

        if (type === 'Event' && recurringInfo && recurringInfo.trim() !== '') {
            console.log(`Regenerating recurring series for event ID: ${id}`);
            const originalRecord = await table.find(id);
            const combinedData = { ...originalRecord.fields, ...result };
            
            const imageFile = result.files.find(f => f.fieldname === 'promoImage');
            if (imageFile && imageFile.content.length > 0) {
                const uploadedImage = await uploadImage(imageFile, 'brumoutloud_events');
                combinedData['Promo Image'] = [{ url: uploadedImage.secure_url }];
            }

            // **THE FIX**: Before creating, simplify the complex attachment object 
            // from the original record into the simple format Airtable requires for creation.
            if (combinedData['Promo Image'] && combinedData['Promo Image'][0] && combinedData['Promo Image'][0].id) {
                const existingImageUrl = combinedData['Promo Image'][0].url;
                combinedData['Promo Image'] = [{ url: existingImageUrl }];
            }

            const datesToCreate = await getDatesFromAI(result.date, recurringInfo);
            
            const recordsToCreate = datesToCreate.map((date, index) => {
                let fields = { ...combinedData };
                fields.Date = `${date}T${result.time || '00:00'}:00.000Z`;
                fields['Recurring Info'] = index === 0 ? recurringInfo : '';
                fields.Status = 'Approved';
                if (result.Category) {
                    fields.Category = Array.isArray(result.Category) ? result.Category : [result.Category];
                }

                const autoGeneratedFields = ['id', 'Slug', 'Created', 'Venue Name', 'Venue Slug', 'files', 'date', 'time', 'Contact Email', 'promoImage', 'photo'];
                autoGeneratedFields.forEach(f => delete fields[f]);

                return { fields };
            });

            await table.destroy(id);
            const chunkSize = 10;
            for (let i = 0; i < recordsToCreate.length; i += chunkSize) {
                await table.create(recordsToCreate.slice(i, i + chunkSize));
            }
            return { statusCode: 200, body: JSON.stringify({ success: true, message: `Successfully regenerated recurring series for ${combinedData['Event Name']}.` }) };

        } else {
            const fieldsToUpdate = {};
            const allowedTextFields = [ 'Event Name', 'VenueText', 'Description', 'Link', 'Parent Event Name', 'Recurring Info', 'Name', 'Address', 'Opening Hours', 'Accessibility', 'Website', 'Instagram', 'Facebook', 'TikTok' ];
            allowedTextFields.forEach(field => {
                if (result[field] !== undefined) {
                    fieldsToUpdate[field] = result[field];
                }
            });

            const imageFile = result.files.find(f => f.fieldname === 'promoImage' || f.fieldname === 'photo');
            if (imageFile && imageFile.content.length > 0) {
                 if (type === 'Event') {
                    const uploadedImage = await uploadImage(imageFile, 'brumoutloud_events');
                    fieldsToUpdate['Promo Image'] = [{ url: uploadedImage.secure_url }];
                } else { // Venue
                    const uploadedImage = await uploadImage(imageFile, 'brumoutloud_venues');
                    fieldsToUpdate['Photo'] = [{ url: uploadedImage.secure_url }];
                    fieldsToUpdate['Photo URL'] = uploadedImage.secure_url;
                    fieldsToUpdate['Photo Medium URL'] = uploadedImage.eager[0].secure_url;
                    fieldsToUpdate['Photo Thumbnail URL'] = uploadedImage.eager[1].secure_url;
                }
            }

            if (type === 'Event') {
                if (result.date) {
                    fieldsToUpdate['Date'] = `${result.date}T${result.time || '00:00'}:00.000Z`;
                }
                if (result.Category) {
                    fieldsToUpdate.Category = Array.isArray(result.Category) ? result.Category : [result.Category];
                }
            }
            
            console.log("Attempting to update Airtable with these fields:", JSON.stringify(fieldsToUpdate, null, 2));
            await table.update(id, fieldsToUpdate);
            return { statusCode: 200, body: JSON.stringify({ success: true, message: `Record ${id} updated successfully.` }) };
        }
    } catch (error) {
        console.error("Error updating submission:", error);
        return {
            statusCode: 500,
            body: JSON.stringify({ success: false, message: error.toString() }),
        };
    }
};
